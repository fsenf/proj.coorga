
##LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
## automatically generated by 25-Autocorrelation_of_PCF.ipynb
##TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT

# TODO 
# make a routine without IO
# use atlantic masking capabilities


import tropy.analysis_tools.grid_and_interpolation as gi
import numpy as np

######################################################################
######################################################################

def get_number_tseries(d):

    '''
    Calculates number time series.

    
    Parameters
    ----------
    d : dict
        set of cell properties

    
    Returns
    --------
    N : numpy array, 1d
        number time series
    
    '''
    
    N = []
    tname = 'time_id'
    time_ids = sorted( set(d[tname]) )
    
    for tid in time_ids:
        m = d[tname] == tid
        N.append ( m.sum() )
        # N.append ( m[m].shape[0] )
        
    N = np.array(N)

    return N

######################################################################
######################################################################

def get_number_per_component_tseries(d, pcount_name = 'pcount_diameter'):

    '''
    Calculates number time series per component. IDs are needed.

    
    Parameters
    ----------
    d : dict
        set of cell properties

    
    Returns
    --------
    Nsum : numpy array, 2d per component, shape = (ntimes, ncomponent)
        number time series
    
    '''
    
    N = []
    tname = 'time_id'
    time_ids = sorted( set(d[tname]) )
    ntimes = len( time_ids )

    # get label field
    ids = d['%s_ids' % pcount_name]
    

    # initialize field
    ncells, ncomponent, nrbins = d[pcount_name].shape
    Nsum = np.zeros((ntimes, ncomponent))
    
    
    for i, tid in enumerate( time_ids ):
        mtime = (d[tname] == tid)
    
        for n in range(ncomponent):
            m = (ids == n) & mtime
            
            Nsum[i,n] = m.sum()
        
    Nsum = np.array(Nsum)

    return Nsum


######################################################################
######################################################################

def get_pairnumber_per_component_tseries(d):
       
    '''
    Calculates time series of pair number per component. IDs are needed.

    
    Parameters
    ----------
    d : dict
        set of cell properties

    
    Returns
    --------
    Npair : numpy array, 2d per component, shape = (ntimes, ncomponent)
        pair number time series
    
    '''


    Nc = get_number_per_component_tseries(d)

    ntimes, ncomponent = Nc.shape
    
    Npair = np.zeros( (ntimes, ncomponent, ncomponent) )
    
    for n1 in range(ncomponent):
        for n2 in range(ncomponent):
            
            if n1 == n2:
                fac = -1
            else:
                fac = 0
            
            Npair[:, n1, n2] = Nc[:, n1] * (Nc[:, n2] + fac) 
            
    return Npair

######################################################################
######################################################################
