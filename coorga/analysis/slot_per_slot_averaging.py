#!/usr/bin/env python

import numpy as np

from get_cluster_id import get_cluster_id

######################################################################
######################################################################

##LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
## automatically generated by 21-Plot_size-dependent_PCF_from_Bootstrap.ipynb
##TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT


def slot_per_slot_averaging(f, d, mask = True, identifier_name = 'time_id'):

    '''
    Uses an identifier ID for categorization and averages a variable f for same IDs.


    Parameters
    ----------
    f : numpy array
       variable that is average for same IDs;
       f can be of rank n <=3, but 1st dimension must be cell dimension

    d : dict
       dictionary (typically cell propertes dict) that contains IDs entries

    mask : boolean numpy array, optional, default = True
       additional mask array to apply conditioned averaging

    identifier_name : str, default = 'time_id'
       name of the identifier variable in d
       

    Returns
    -------
    fave : numpy array
       averaged field f conditioned on different ID values
    
    '''

    gts = []
    time_ids = sorted( set(d['time_id']) )

    
    if np.ndim(f) == 2:
        ncell, ncol = f.shape
        nan = np.nan * np.zeros(ncol)

    elif np.ndim(f) == 3:
        ncell, nrow, ncol = f.shape
        nan = np.nan * np.zeros( (nrow,ncol) )
    
    elif np.ndim(f) == 1:
        nan = np.nan
        
    for tid in time_ids:

        # time masking 
        tmask = (d['time_id'] == tid) 
        
        # additional masking
        m = tmask & mask
        
        gm = f[m].mean(axis = 0)
        
        if m.sum() == 0:
            gts.append( nan )
        else:
            gts.append( gm )

    fave = np.ma.masked_invalid( np.array(gts) )
    
    return fave

######################################################################
######################################################################


def time_ave_ncounts(dset, pcount_name):

    '''
    Calculates time-average pcounts.

    
    Parameters
    ----------
    dset : dict
        set of cell properties

    pcount_name : str
        name of the pcount variable

    '''
    

    # set time vector
    time_id = dset['time_id']
    time_set = sorted( set(time_id) )
    
    ntimes = len( time_set )

    
    # extract field
    rbins = dset['%s_rbins' % pcount_name]
    var_set = dset['%s_variable_set' % pcount_name]
    var_name = dset['%s_variable_name' % pcount_name]
    ids = dset['%s_ids' % pcount_name]
    pcount =  dset[pcount_name]

    
    # initialize field
    ncells, ncomponent, nrbins = pcount.shape
    Cr = np.zeros((ntimes, ncomponent, ncomponent, nrbins))


    for i, tid in enumerate( time_set ):
        mtime = (time_id == tid)
    
        for n in range(ncomponent):
            m = (ids == n) & mtime
            
            if m.sum() != 0:
                Cr[i, n] = pcount[m].sum(axis = 0)   

    return rbins, Cr
